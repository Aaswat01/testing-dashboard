<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>AI Eco Driving Dashboard - Location-Based Navigation</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
<style>
*{box-sizing:border-box;margin:0;padding:0;}
body{
background:radial-gradient(circle at top left,#2a4b7a,#1c2b44,#2a3b60);
font-family:"Segoe UI",Arial,sans-serif;color:#fff;
height:100vh;display:flex;flex-direction:column;overflow:hidden;
}
/* === HEADER === */
.ai-tip-box{flex:0 0 auto;background:#ffa500;color:#000;border-radius:1vh;
margin:1vh 2vw;padding:1.5vh 1vw;text-align:center;font-weight:bold;
font-size:clamp(1rem,2vw,1.6rem);box-shadow:0 0.5vh 1vh rgba(0,0,0,0.4);}
.stats-row{display:flex;justify-content:space-evenly;align-items:stretch;
flex-wrap:wrap;gap:1vh;margin:0 1vw;}
.stat-card{flex:1;min-width:120px;max-width:180px;background:rgba(28,34,48,0.95);
border-radius:1vh;padding:1vh;display:flex;flex-direction:column;justify-content:center;
align-items:center;text-align:center;border:1px solid rgba(255,255,255,0.2);
box-shadow:0 0.3vh 1vh rgba(0,0,0,0.4);}
.stat-label{font-size:0.9rem;opacity:0.8;}
.stat-value{font-size:1.3rem;font-weight:bold;margin-top:0.3rem;}
.speed-box{background:#4e79a7;}
.gear-box{background:#76b7b2;color:#000;}
.throttle-box{background:#2ca02c;color:#000;}
/* === SEARCH === */
.search-row{display:flex;align-items:center;justify-content:center;gap:1vw;margin:1vh 2vw;position:relative;}
#searchInput{flex:1;max-width:70%;padding:0.8vh 1vw;font-size:1rem;border-radius:1vh;
border:none;outline:none;}
#micBtn{background:#ff4c4c;color:#fff;border:none;border-radius:1vh;padding:0.8vh 1.2vw;
font-weight:bold;cursor:pointer;box-shadow:0 0.4vh 1vh rgba(0,0,0,0.3);}
#suggestBox{position:absolute;top:100%;left:10%;width:80%;background:rgba(0,0,0,0.9);
border-radius:1vh;max-height:40vh;overflow-y:auto;z-index:2000;display:none;}
.suggest-item{padding:0.8vh 1vw;border-bottom:1px solid rgba(255,255,255,0.1);cursor:pointer;}
.suggest-item:hover{background:rgba(255,255,255,0.1);}
/* === MAIN (Map now fills space) === */
.main-section{flex:1;display:flex;flex-direction:column;gap:1vh;padding:0 2vw 1vh;}
.map-container{flex:1;position:relative;border-radius:1vh;overflow:hidden;
border:1px solid rgba(255,255,255,0.2);box-shadow:0 0.5vh 1vh rgba(0,0,0,0.4);}
.map{width:100%;height:100%;}
/* === Locate (Target) Button === */
#locate-btn {
  position: absolute;
  bottom: 2vh;
  right: 1vh;
  z-index: 1000;
  background: #1e90ff;
  color: #fff;
  border: none;
  border-radius: 50%;
  width: 42px;
  height: 42px;
  font-size: 1.2rem;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 0.4vh 1vh rgba(0,0,0,0.4);
  display: flex;
  justify-content: center;
  align-items: center;
  transition: transform 0.2s ease, background 0.3s ease;
}
#locate-btn:hover {background: #4682b4;transform: scale(1.1);}
#map-toggle{position:absolute;top:1vh;right:1vh;z-index:1000;background:#ff8c00;
border:none;border-radius:1vh;padding:0.5vh 1vw;font-weight:bold;cursor:pointer;color:#000;}
/* === ROUTE PANEL === */
#routePanel{position:absolute;bottom:2vh;left:2vw;width:270px;max-height:42vh;
overflow-y:auto;background:rgba(0,0,0,0.6);border-radius:1vh;padding:0.5vh;color:#fff;z-index:999;}
.route-box{margin-bottom:0.8vh;border-radius:1vh;overflow:hidden;background:rgba(255,255,255,0.05);backdrop-filter:blur(6px);box-shadow:0 0.4vh 1vh rgba(0,0,0,0.5);}
.route-header{padding:0.6vh 0.6vw;font-weight:bold;display:flex;justify-content:space-between;
align-items:center;color:#fff;font-size:0.9rem;}
.route-content{background:rgba(255,255,255,0.1);padding:0.4vh 0.6vw;font-size:0.85rem;max-height:30vh;overflow-y:auto;transition:all 0.3s ease;}
.route-step{padding:0.4vh 0.3vw;margin-bottom:0.4vh;border-bottom:1px solid rgba(255,255,255,0.1);transition:all 0.3s ease;}
.route-step:hover{background:rgba(255,255,255,0.15);}
.route-step.completed{display:none;} /* üÜï HIDE completed steps */
.route-step.active{background:rgba(255,215,0,0.3);font-weight:bold;border-left:3px solid gold;}
.route-step.upcoming{opacity:0.7;}

/* Car Icon Style */
.user-car-icon {
    width: 32px;
    height: 32px;
    display: flex;
    justify-content: center;
    align-items: center;
}
.user-car-svg {
    transform-origin: center;
    transition: transform 0.3s linear;
}
/* === Slide-up Approval Panel === */
#approvalPanel{
  position:absolute;
  left:50%;
  bottom:1.5vh;
  transform:translate(-50%, 130%);
  width:min(92vw,460px);
  background:rgba(20,24,36,0.96);
  border:1px solid rgba(255,255,255,0.15);
  border-radius:14px;
  box-shadow:0 0.8vh 2vh rgba(0,0,0,0.5);
  padding:12px 14px;
  z-index:1100;
  transition:transform .28s ease;
  backdrop-filter:blur(6px);
}
#approvalPanel.show{ transform:translate(-50%, 0); }

.approval-row{ display:flex; gap:10px; align-items:center; }
.approval-icon{
  flex:0 0 40px; height:40px; border-radius:10px;
  display:flex; align-items:center; justify-content:center;
  background:#24324f; font-size:1.2rem;
}
.approval-main{ flex:1; min-width:0; }
.approval-title{ font-weight:700; font-size:0.98rem; line-height:1.2; }
.approval-sub{ font-size:0.82rem; opacity:0.8; margin-top:2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

.approval-actions{ display:flex; gap:10px; margin-top:10px; }
.btn-ghost, .btn-solid{
  flex:1; padding:10px 12px; border-radius:10px; font-weight:700; border:none; cursor:pointer;
  box-shadow:0 0.4vh 1.2vh rgba(0,0,0,0.35);
}
.btn-ghost{ background:transparent; border:1px solid rgba(255,255,255,0.22); color:#fff; }
.btn-ghost:hover{ background:rgba(255,255,255,0.07); }
.btn-solid{ background:#00b36b; color:#fff; }
.btn-solid:hover{ filter:brightness(0.95); }

.approval-chips{ display:flex; gap:8px; margin-top:6px; }
.chip{
  font-size:0.78rem; padding:5px 8px; border-radius:8px;
  background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.12);
}

</style>
</head>
<body>
<div class="ai-tip-box" id="ai-tip">Starting system...</div>
<div class="stats-row">
  <div class="stat-card speed-box"><div class="stat-label">Speed</div><div class="stat-value" id="speed">0 km/h</div></div>
  <div class="stat-card gear-box"><div class="stat-label">Gear</div><div class="stat-value" id="gear">N</div></div>
  <div class="stat-card throttle-box"><div class="stat-label">Throttle</div><div class="stat-value" id="throttle">0%</div></div>
</div>

<div class="search-row">
  <input type="text" id="searchInput" placeholder="Search destination...">
  <button id="micBtn">üé§</button>
  <div id="suggestBox"></div>
</div>

<div class="main-section">
  <div class="map-container">
    <div id="map" class="map"></div>
    <button id="map-toggle">Full Map</button>
    <button id="locate-btn" title="Recenter to my location">üéØ</button>
    <div id="routePanel"></div>
    <div id="approvalPanel" aria-live="polite">
      <div class="approval-row">
        <div class="approval-icon">üìç</div>
        <div class="approval-main">
          <div class="approval-title" id="approvalTitle">Start navigation?</div>
          <div class="approval-sub" id="approvalSubtitle">Destination</div>
          <div class="approval-chips">
            <div class="chip" id="approvalDistance">‚Äî</div>
            <div class="chip" id="approvalDuration">‚Äî</div>
          </div>
        </div>
      </div>
      <div class="approval-actions">
        <button id="approvalCancel" class="btn-ghost">Cancel</button>
        <button id="approvalStart"  class="btn-solid">Start</button>
      </div>
    </div>
  </div>
</div>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
<script>
// ==============================
// LOCATION-FIRST NAVIGATION SYSTEM
// Priority: Driver's actual location > Pre-planned announcements
// ==============================

let currentMapRotation = 0;
function rotateMap(angle) {
  currentMapRotation = angle;
  const mapPane = map.getPane('mapPane');
  if (mapPane) {
    mapPane.style.transform = `rotate(${angle}deg)`;
    mapPane.style.transformOrigin = "center center";
  }
  const controlPane = map.getPane('controlPane');
  if (controlPane) controlPane.style.transform = `rotate(${-angle}deg)`;
}

const map = L.map('map').setView([0, 0], 2);
let autoFollow = true;

const englishMap = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; OpenStreetMap contributors | ¬© CartoDB',
  subdomains: 'abcd', maxZoom: 19
});
const googleMap = L.tileLayer('https://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', {
  maxZoom: 23, subdomains: ['mt0','mt1','mt2','mt3']
});
const osmMap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
});
googleMap.addTo(map);
L.control.layers(
  { "üó∫Ô∏è English Map": englishMap, "üåç Google Map": googleMap, "üó∫Ô∏è Map": osmMap },
  null, { position: "topright", collapsed: true }
).addTo(map);

const carIcon = L.divIcon({
  className: 'user-car-icon',
  html: '<svg id="user-car-svg" class="user-car-svg" width="32" height="32" viewBox="0 0 100 100" fill="#2a3b60" stroke="#fff" stroke-width="3"><path d="M 25 20 L 75 20 L 80 45 L 90 45 L 90 70 L 10 70 L 10 45 L 20 45 Z" /></svg>',
  iconSize: [32,32], iconAnchor: [16,16]
});

let userMarker = null, waypoints = [], waypointMarkers = [], routes = [];
const colors = ['#FF6B6B','#4DA6FF','#FFD93D','#6BCB77','#FF8C00','#9B59B6','#00BFA5'];

let activeRouteIndex = null;
let currentStepIndex = 0;
let ECO_START_BLOCK = Date.now() + 3000;
let currentRoadType = "city";
let lastSlope = 0;

// üÜï Track which steps have been announced to avoid repeating
let announcedSteps = new Set();

const UI = {
  aiBox: document.getElementById("ai-tip"),
  speedEl: document.getElementById("speed"),
  gearEl: document.getElementById("gear"),
  throttleEl: document.getElementById("throttle"),
};

const SPEECH = {
  ECO_COOLDOWN: 20000,
  ECO_PERIODIC: 35000,
  STEP_REMINDER: 20000,
  WARNING_HOLD: 3500,
  LOOKAHEAD_DISTANCE: 150, // üÜï Reduced from 300m - announce when 150m away
  STEP_ARRIVAL_THRESHOLD: 30, // üÜï Consider "arrived" when within 30m

  lastEcoText: "",
  lastEcoSpokenAt: 0,
  lastRoadType: "",
  lastSlopeBucket: "flat",
  lastStepText: "",
  lastStepSpokenAt: 0,
  warningActiveUntil: 0,
  currentDisplay: { kind: "eco", text: "" },
};

function nowMs() { return Date.now(); }

function aiBoxShow(kind, text) {
  SPEECH.currentDisplay = { kind, text };
  if (kind === "warning") UI.aiBox.textContent = "‚ö†Ô∏è " + text;
  else if (kind === "step") UI.aiBox.textContent = "üß≠ " + text;
  else UI.aiBox.textContent = "üí° " + text;
}

function speak(text, kind, { interrupt=false } = {}) {
  try { if (interrupt) speechSynthesis.cancel(); } catch {}
  const u = new SpeechSynthesisUtterance(text);
  u.rate = 1; u.pitch = 1;
  speechSynthesis.speak(u);

  if (kind === "warning") {
    SPEECH.warningActiveUntil = nowMs() + SPEECH.WARNING_HOLD;
    aiBoxShow("warning", text);
    u.onend = () => {
      SPEECH.warningActiveUntil = 0;
      refreshAIBox();
    };
  } else if (kind === "step") {
    SPEECH.lastStepText = text;
    SPEECH.lastStepSpokenAt = nowMs();
    aiBoxShow("step", text);
  } else {
    SPEECH.lastEcoText = text;
    SPEECH.lastEcoSpokenAt = nowMs();
    aiBoxShow("eco", text);
  }
}

function refreshAIBox() {
  const t = nowMs();
  if (t < SPEECH.warningActiveUntil) return;
  if (SPEECH.lastStepText && (t - SPEECH.lastStepSpokenAt) < SPEECH.STEP_REMINDER) {
    aiBoxShow("step", SPEECH.lastStepText);
  } else {
    aiBoxShow("eco", SPEECH.lastEcoText);
  }
  if (SPEECH.lastEcoText) aiBoxShow("eco", SPEECH.lastEcoText);
}

// ===== Preview / approval panel =====
let preview = { active:false, group:null, polyline:null, osrmRoute:null, start:null, end:null, destLabel:"", tempMarker:null };

const approvalPanel = document.getElementById("approvalPanel");
const approvalTitle = document.getElementById("approvalTitle");
const approvalSubtitle = document.getElementById("approvalSubtitle");
const approvalDistance = document.getElementById("approvalDistance");
const approvalDuration = document.getElementById("approvalDuration");
const approvalStartBtn = document.getElementById("approvalStart");
const approvalCancelBtn = document.getElementById("approvalCancel");

function fmtKm(m){ return (m/1000).toFixed(m>=10000 ? 0 : 1) + " km"; }
function fmtMin(s){
  const m = Math.round(s/60); if (m < 60) return m + " min";
  const h = Math.floor(m/60), mm = m%60; return `${h} hr ${mm?mm+" min":""}`.trim();
}

function clearPreview(){
  if (preview.polyline && preview.group) { try { preview.group.removeLayer(preview.polyline); } catch {} }
  if (preview.group) { try { map.removeLayer(preview.group); } catch {} }
  if (preview.tempMarker) { try { map.removeLayer(preview.tempMarker); } catch {} }
  preview = { active:false, group:null, polyline:null, osrmRoute:null, start:null, end:null, destLabel:"", tempMarker:null };
  approvalPanel.classList.remove("show");
}

function buildPreviewRoute(startLL, endLL, labelText){
  clearPreview();
  const router = L.Routing.osrmv1({ serviceUrl: 'https://router.project-osrm.org/route/v1' });
  const wp = [{ latLng: L.latLng(startLL) }, { latLng: L.latLng(endLL) }];
  router.route(wp, (err, routesResp) => {
    if (err || !routesResp || !routesResp[0]) { console.warn("Preview routing failed:", err); return; }
    const r = routesResp[0];
    preview.active = true; preview.osrmRoute = r; preview.start = L.latLng(startLL);
    preview.end = L.latLng(endLL); preview.destLabel = labelText || "Selected destination";
    preview.group = L.layerGroup().addTo(map);
    preview.polyline = L.polyline(r.coordinates.map(c => [c.lat, c.lng]), { color:'#4DA6FF', weight:5, opacity:0.9 }).addTo(preview.group);
    approvalTitle.textContent = "Start navigation?";
    approvalSubtitle.textContent = preview.destLabel;
    approvalDistance.textContent = fmtKm(r.summary.totalDistance);
    approvalDuration.textContent = fmtMin(r.summary.totalTime);
    approvalPanel.classList.add("show");
  });
}

function openPreviewTo(latlng, label, addTempMarker = true){
  const start = userMarker ? userMarker.getLatLng() : map.getCenter();
  if (addTempMarker){
    if (preview.tempMarker) { try { map.removeLayer(preview.tempMarker); } catch {} }
    preview.tempMarker = L.marker(latlng).addTo(map);
  }
  buildPreviewRoute(start, latlng, label);
}

approvalStartBtn.addEventListener("click", () => {
  if (!preview.active || !preview.end) return;
  const start = userMarker ? userMarker.getLatLng() : map.getCenter();
  if (!waypoints.length) waypoints.push(start); else waypoints[0] = start;
  const destMarker = L.marker(preview.end).addTo(map);
  waypointMarkers.push(destMarker); waypoints.push(preview.end);
  const endLL = preview.end; clearPreview();
  createRoute(waypoints[waypoints.length - 2], endLL, colors[routes.length % colors.length], destMarker);
});
approvalCancelBtn.addEventListener("click", clearPreview);

// ===== Speed, road type, elevation =====
function calculateGPSSpeed(latlng){
  const now = Date.now();
  if (window._lastGPSPos && window._lastGPSTime){
    const dist = latlng.distanceTo(window._lastGPSPos);
    const dt = (now - window._lastGPSTime)/1000;
    window._lastGPSPos = latlng; window._lastGPSTime = now;
    return (dist/dt)*3.6;
  } else { window._lastGPSPos = latlng; window._lastGPSTime = now; return 0; }
}

async function getRoadType(latlng) {
  const lastSp = calculateGPSSpeed(latlng);
  if (lastSp > 80) currentRoadType = "highway";
  else if (lastSp > 40) currentRoadType = "residential";
  else if (lastSp > 10) currentRoadType = "city";
  else currentRoadType = "residential";
  return currentRoadType;
}

function ecoAdvisor(distAhead, slope){
  let tip = "", speed = 40, gear = 3, throttle = 45;
  switch (currentRoadType) {
    case "highway": speed = 80; gear = 5; throttle = 55; tip = "Highway ‚Äî maintain steady speed."; break;
    case "city": speed = 30; gear = 3; throttle = 40; tip = "City ‚Äî anticipate stops."; break;
    case "residential": speed = 25; gear = 3; throttle = 35; tip = "Residential ‚Äî maintain low speed."; break;
    case "mountain": speed = 35; gear = 2; throttle = 50; tip = "Mountain ‚Äî use engine braking."; break;
    default: tip = "Smooth driving.";
  }
  if (slope > 2.5) tip += " Downhill ahead.";
  else if (slope < -2.5) tip += " Uphill ahead.";
  if (distAhead > 700 && Math.abs(slope) < 3) tip += " Long straight ahead.";
  return { speed, gear, throttle, tip, slope };
}

const ELEVATION_INTERVAL = 50;
const LOOKAHEAD_DISTANCE = 200;
async function getElevations(coords){
  try {
    return new Array(coords.length).fill(0).map((_, i) => Math.sin(i * 0.1) * 50 + Math.random() * 5);
  } catch { return new Array(coords.length).fill(0); }
}
async function predictElevationAhead(latlng, heading){
  const R=6378137; const pts=[];
  for(let d=ELEVATION_INTERVAL; d<=LOOKAHEAD_DISTANCE; d+=ELEVATION_INTERVAL){
    const latRad=latlng.lat*Math.PI/180, lonRad=latlng.lng*Math.PI/180;
    const newLat=latRad+(d*Math.cos(heading*Math.PI/180))/R;
    const newLng=lonRad+(d*Math.sin(heading*Math.PI/180))/(R*Math.cos(latRad));
    pts.push({lat:newLat*180/Math.PI,lng:newLng*180/Math.PI});
  }
  const elevs = await getElevations(pts);
  if (elevs.length < 2) return { elevs, slope: 0 };
  const elevationChange = elevs[elevs.length - 1] - elevs[0];
  const avgSlope = (elevationChange / LOOKAHEAD_DISTANCE) * 100;
  return { elevs, slope: avgSlope };
}

function slopeBucket(slope){
  if (slope > 2.5) return "downhill";
  if (slope < -2.5) return "uphill";
  return "flat";
}

function maybeSpeakEco(eco) {
  const t = nowMs();
  const bucket = slopeBucket(eco.slope);
  const roadChanged = SPEECH.lastRoadType !== currentRoadType;
  const slopeChanged = bucket !== SPEECH.lastSlopeBucket;
  SPEECH.lastSlopeBucket = bucket;
  const periodicDue = (t - SPEECH.lastEcoSpokenAt) > SPEECH.ECO_PERIODIC;
  const tipText = `Road type: ${currentRoadType}. ${bucket === "uphill" ? "Uphill ahead." : bucket === "downhill" ? "Downhill ahead." : "Level road."} ` +
                  `Recommended ${eco.speed}.`;

  SPEECH.lastEcoText = tipText;
  SPEECH.lastRoadType = currentRoadType;
  SPEECH.lastSlopeBucket = bucket;

  if (nowMs() >= SPEECH.warningActiveUntil && (!SPEECH.lastStepText || (t - SPEECH.lastStepSpokenAt) > SPEECH.STEP_REMINDER)) {
    aiBoxShow("eco", tipText);
  }
  const canSpeak = nowMs() > SPEECH.warningActiveUntil;
  const cooldownOk = (t - SPEECH.lastEcoSpokenAt) > SPEECH.ECO_PERIODIC;
  if (activeRouteIndex !== null) {
    if ((t - SPEECH.lastStepSpokenAt) < (SPEECH.STEP_REMINDER - 2000)) return;
  }
  if (canSpeak && cooldownOk && (roadChanged || slopeChanged || periodicDue)) {
    speak(tipText, "eco", { interrupt:false });
  }
}

let driverStats = { overspeed:0, totalPoints:0 };
let spokeOverspeedOnce = false;

function checkWarnings(currentSpeed, eco) {
  driverStats.totalPoints++;
  const isOver = currentSpeed > (eco.speed + 10);
  if (isOver) {
    driverStats.overspeed++;
    const text = "Slow down. You are over the recommended speed.";
    speak(text, "warning", { interrupt:true });
    spokeOverspeedOnce = true;
  } else {
    spokeOverspeedOnce = false;
  }
}

// üÜï Update UI to mark steps
function updateStepUI(routeIndex, stepIndex, status) {
  const route = routes.find(r => r.routeIndex === routeIndex);
  if (!route || !route.steps[stepIndex]) return;
  const step = route.steps[stepIndex];
  if (step.element) {
    step.element.classList.remove('completed', 'active', 'upcoming');
    if (status === 'completed') {
      step.element.classList.add('completed'); // Will be hidden by CSS
    } else if (status === 'active') {
      step.element.classList.add('active');
    } else if (status === 'upcoming') {
      step.element.classList.add('upcoming');
    }
  }
}

// üÜï LOCATION-BASED STEP DETECTION
// This function finds which step the driver is ACTUALLY at right now
function findCurrentStepByLocation(latlng, route) {
  if (!route || !route.steps || route.steps.length === 0) return null;
  
  const steps = route.steps;
  let closestStepIndex = -1;
  let closestDistance = Infinity;
  
  // Check all remaining steps (from currentStepIndex onwards)
  for (let i = currentStepIndex; i < steps.length; i++) {
    const stepLL = L.latLng(steps[i].lat, steps[i].lng);
    const dist = latlng.distanceTo(stepLL);
    
    // If driver is within arrival threshold of this step
    if (dist < SPEECH.STEP_ARRIVAL_THRESHOLD && dist < closestDistance) {
      closestDistance = dist;
      closestStepIndex = i;
    }
  }
  
  return closestStepIndex >= 0 ? { index: closestStepIndex, distance: closestDistance } : null;
}

// üÜï SMART STEP ADVANCEMENT
// Handles skipping missed steps and announcing current location
function smartStepAdvancement(latlng) {
  if (activeRouteIndex === null || !routes[activeRouteIndex]) return;
  
  const route = routes[activeRouteIndex];
  const steps = route.steps;
  
  // Find where driver actually is
  const locationResult = findCurrentStepByLocation(latlng, route);
  
  if (locationResult && locationResult.index !== currentStepIndex) {
    // Driver has moved to a different step!
    const newStepIndex = locationResult.index;
    
    console.log(`üöó Location jump detected: ${currentStepIndex} ‚Üí ${newStepIndex}`);
    
    // Mark all skipped steps as completed (hide them)
    for (let i = currentStepIndex; i < newStepIndex; i++) {
      updateStepUI(activeRouteIndex, i, 'completed');
      if (steps[i].lineLayer) route.group.removeLayer(steps[i].lineLayer);
      if (steps[i].connectorLine) route.group.removeLayer(steps[i].connectorLine);
    }
    
    // Update current step
    currentStepIndex = newStepIndex;
    announcedSteps.clear(); // Reset announcements
    
    // If this is the last step (destination)
    if (currentStepIndex >= steps.length - 1) {
      updateStepUI(activeRouteIndex, currentStepIndex, 'completed');
      speak("Destination reached.", "step", { interrupt: true });
      UI.aiBox.textContent = "Destination reached ‚úÖ";
      
      setTimeout(() => {
        cleanupRoute(route);
      }, 3000);
      return;
    }
    
    // Mark current step as active and announce it
    updateStepUI(activeRouteIndex, currentStepIndex, 'active');
    const step = steps[currentStepIndex];
    const distText = step.distance < 1000 
      ? `${step.distance.toFixed(0)} meters` 
      : `${(step.distance / 1000).toFixed(1)} kilometers`;
    
    const announcement = `${step.text}. Proceed for ${distText}.`;
    speak(announcement, "step", { interrupt: true });
    announcedSteps.add(currentStepIndex);
  }
}

// üÜï Check for upcoming step announcements
function checkUpcomingSteps(latlng) {
  if (activeRouteIndex === null || !routes[activeRouteIndex]) return;
  
  const route = routes[activeRouteIndex];
  const steps = route.steps;
  
  // Check next step (not current)
  const nextStepIndex = currentStepIndex + 1;
  if (nextStepIndex < steps.length && !announcedSteps.has(`lookahead_${nextStepIndex}`)) {
    const nextStep = steps[nextStepIndex];
    const nextStepLL = L.latLng(nextStep.lat, nextStep.lng);
    const distToNext = latlng.distanceTo(nextStepLL);
    
    // Announce when within lookahead distance
    if (distToNext <= SPEECH.LOOKAHEAD_DISTANCE) {
      const distText = Math.round(distToNext) + " meters";
      speak(`In ${distText}, ${nextStep.text}`, "step", { interrupt: false });
      announcedSteps.add(`lookahead_${nextStepIndex}`);
    }
  }
}

function cleanupRoute(route) {
  try { map.removeControl(route.rc); } catch {}
  try { map.removeLayer(route.group); } catch {}
  const destIndex = waypointMarkers.length - 1;
  if (waypointMarkers[destIndex]) {
    map.removeLayer(waypointMarkers[destIndex]);
    waypointMarkers.splice(destIndex, 1);
    waypoints.splice(destIndex + 1, 1);
  }
  const box = document.getElementById(`route-box-${route.routeIndex}`);
  if (box) box.remove();
  routes.splice(activeRouteIndex, 1);
  activeRouteIndex = null;
  currentStepIndex = 0;
  announcedSteps.clear();
  SPEECH.lastStepText = "";
  SPEECH.lastStepSpokenAt = 0;
  SPEECH.currentDisplay.kind = "eco";
  rebuildRoutes();
  refreshAIBox();
}

// ===== Main AI loop =====
async function adaptiveAIDashboard(latlng, heading) {
  const currentSpeed = calculateGPSSpeed(latlng);
  const slopeData = await predictElevationAhead(latlng, heading);
  const slope = slopeData.slope;
  await getRoadType(latlng);

  const eco = ecoAdvisor(800, slope);
  lastSlope = slope;

  UI.speedEl.textContent = `${eco.speed} km/h`;
  UI.gearEl.textContent = `${eco.gear}`;
  UI.throttleEl.textContent = `${eco.throttle}%`;

  if (activeRouteIndex !== null && routes.length > 0 && routes[activeRouteIndex]) {
    const route = routes[activeRouteIndex];
    const steps = route.steps;
    const routeDisplayIndex = route.routeIndex;

    // üÜï LOCATION-FIRST: Check if driver has jumped to a different step
    smartStepAdvancement(latlng);
    
    // üÜï Check for upcoming step announcements
    checkUpcomingSteps(latlng);

    // Calculate remaining distance
    let remaining = 0;
    for (let i = currentStepIndex; i < steps.length; i++) remaining += steps[i].distance;
    const distanceEl = document.getElementById(`route-distance-${routeDisplayIndex}`);
    if (distanceEl) distanceEl.textContent = `${(remaining / 1000).toFixed(1)} km remaining`;
  }

  checkWarnings(currentSpeed, eco);
  maybeSpeakEco(eco);
}

// ===== GPS watch =====
if (navigator.geolocation){
  navigator.geolocation.watchPosition(async pos=>{
    const latlng = L.latLng(pos.coords.latitude, pos.coords.longitude);
    const currentSpeed = calculateGPSSpeed(latlng);
    let heading = pos.coords.heading;
    const MIN_SPEED_FOR_HEADING = 5/3.6;
    if (heading == null || currentSpeed < MIN_SPEED_FOR_HEADING) {
      const carEl = document.getElementById('user-car-svg');
      if (carEl) {
        const m = (carEl.style.transform || "").match(/rotate\(([^)]+)deg\)/);
        heading = m ? parseFloat(m[1]) : 0;
      } else heading = 0;
    }

    if(!waypoints.length) waypoints.push(latlng); else waypoints[0]=latlng;

    if(!userMarker){ userMarker = L.marker(latlng,{icon:carIcon}).addTo(map); map.setView(latlng,22); }
    else { userMarker.setLatLng(latlng); }

    if (autoFollow) {
      map.setView(latlng, map.getZoom(), { animate:false });
      rotateMap(-heading);
    } else {
      const drift = window._lastCenter ? latlng.distanceTo(window._lastCenter) : 0;
      if (drift > 30) map.panTo(latlng, { animate:true, duration:0.6 });
      window._lastCenter = latlng;
    }

    const carEl = document.getElementById('user-car-svg');
    if (carEl) carEl.style.transform = `rotate(${heading}deg)`;

    await adaptiveAIDashboard(latlng, heading);
  }, ()=>console.warn("GPS unavailable"), { enableHighAccuracy:true, maximumAge:1000, timeout:5000 });
}

let driverCountry = null;
async function updateDriverCountry(latlng) {
  try {
    const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latlng.lat}&lon=${latlng.lng}&zoom=5&addressdetails=1`;
    const res = await fetch(url); const data = await res.json();
    driverCountry = data.address && (data.address.country_code || "").toUpperCase();
  } catch (err) { console.warn("Country fetch failed:", err); }
}

document.addEventListener("visibilitychange", () => {
  if (document.visibilityState !== "visible") return;
  try { speechSynthesis.resume(); } catch {}
  const t = nowMs();
  setTimeout(() => {
    if (t < SPEECH.warningActiveUntil && SPEECH.currentDisplay.kind === "warning") {
      aiBoxShow("warning", SPEECH.currentDisplay.text);
      speak(SPEECH.currentDisplay.text, "warning", { interrupt:true });
      return;
    }
    if (activeRouteIndex !== null && SPEECH.lastStepText) {
      speak(SPEECH.lastStepText, "step", { interrupt:true });
      setTimeout(() => speak(SPEECH.lastEcoText, "eco", { interrupt:false }), 1000);
      return;
    }
    speak(SPEECH.lastEcoText, "eco", { interrupt:true });
  }, 250);
});

// ===== Route creation =====
async function createRoute(start, end, color, marker = null, index = null) {
  const routeIndex = index !== null ? index : routes.length;
  const displayIndex = routeIndex + 1;
  const endKey = `${end.lat.toFixed(6)},${end.lng.toFixed(6)}`;
  if (routes.find(r => r.endKey === endKey)) return;

  const routeColor = color || colors[routeIndex % colors.length];
  const old = routes.find(r => r.routeIndex === routeIndex);
  if (old) { try { map.removeControl(old.rc); } catch {} try { map.removeLayer(old.group); } catch {} }

  const rc = L.Routing.control({
    waypoints: [start, end],
    router: L.Routing.osrmv1({ serviceUrl: "https://router.project-osrm.org/route/v1" }),
    show: false, addWaypoints: false, createMarker: () => null,
    lineOptions: { styles: [{ color: routeColor, weight: 5, opacity: 0.9 }] }
  }).addTo(map);

  const group = L.layerGroup().addTo(map);
  document.querySelectorAll(".leaflet-routing-container").forEach(el => el.style.display = "none");

  let box = document.getElementById(`route-box-${routeIndex}`);
  let header, content;
  if (!box) {
    box = document.createElement("div");
    box.className = "route-box"; box.id = `route-box-${routeIndex}`;
    header = document.createElement("div"); content = document.createElement("div");
    content.className = "route-content"; content.style.display = "block";
    box.appendChild(header); box.appendChild(content);
    document.getElementById("routePanel").appendChild(box);
  } else {
    header = box.querySelector(".route-header"); content = box.querySelector(".route-content");
  }

  header.className = "route-header";
  header.style.background = routeColor;
  header.innerHTML = `
    <b>Route ${displayIndex}</b>
    <span id="route-distance-${routeIndex}" style="font-weight:normal;">Calculating...</span>
    <button class="route-delete" style="background:#ff4c4c;border:none;color:#fff;border-radius:50%;width:22px;height:22px;">‚úï</button>
  `;
  header.onclick = () => content.style.display = content.style.display === "block" ? "none" : "block";
  header.querySelector("button").onclick = () => {
    try { speechSynthesis.cancel(); } catch {}
    try { map.removeControl(rc); } catch {}
    try { map.removeLayer(group); } catch {}
    if (marker) {
      const mIndex = waypointMarkers.indexOf(marker);
      if (mIndex !== -1) {
        map.removeLayer(marker);
        waypointMarkers.splice(mIndex, 1);
        waypoints.splice(mIndex + 1, 1);
      }
    }
    box.remove();
    activeRouteIndex = null;
    currentStepIndex = 0;
    announcedSteps.clear();
    SPEECH.lastStepText = "";
    SPEECH.lastStepSpokenAt = 0;
    routes = routes.filter(r => r.routeIndex !== routeIndex);
    rebuildRoutes();
    refreshAIBox();
  };

  rc.on("routesfound", async e => {
    const r = e.routes[0];
    const coords = r.coordinates.map(c => ({ lat: c.lat, lng: c.lng }));
    const elevs = await getElevations(coords);

    content.innerHTML = "";
    const steps = [];
    r.instructions.forEach((s, i) => {
      const idxStart = s.index;
      const idxEnd = r.instructions[i + 1] ? r.instructions[i + 1].index : coords.length;
      const seg = coords.slice(idxStart, idxEnd).map(c => [c.lat, c.lng]);
      const elev = elevs[idxStart] || 0;
      const line = L.polyline(seg, { color: routeColor, weight: 5, opacity: 0.8 }).addTo(group);
      const div = document.createElement("div");
      div.className = "route-step";
      div.onmouseenter = () => line.setStyle({ weight: 9, opacity: 1, color: "#FFFF33" });
      div.onmouseleave = () => line.setStyle({ weight: 5, opacity: 0.9, color: routeColor });
      div.innerHTML = `<b>${s.text}</b><div>${(s.distance/1000).toFixed(2)} km | Elev ${elev.toFixed(1)} m`;
      content.appendChild(div);
      let connector = null;
      if (i < r.instructions.length - 1) {
        connector = L.polyline([
          [coords[idxStart].lat, coords[idxStart].lng],
          [coords[idxEnd-1].lat, coords[idxEnd-1].lng]
        ], { color: routeColor, weight: 3, opacity: 0.6 }).addTo(group);
      }
      steps.push({ 
        lat: coords[idxStart].lat, 
        lng: coords[idxStart].lng, 
        text: s.text, 
        elev, 
        distance: s.distance, 
        element: div, 
        lineLayer: line, 
        connectorLine: connector,
        expectedHeading: s.heading || 0
      });
    });

    const existing = routes.find(x => x.routeIndex === routeIndex);
    if (existing) { 
      existing.rc = rc; existing.group = group; existing.steps = steps; 
      existing.endKey = endKey; existing.totalDistance = r.summary.totalDistance; 
    } else { 
      routes.push({ rc, group, steps, endKey, routeIndex, totalDistance: r.summary.totalDistance }); 
    }

    document.getElementById(`route-distance-${routeIndex}`).textContent = `${(r.summary.totalDistance/1000).toFixed(1)} km total`;
    if (activeRouteIndex === null) { 
      activeRouteIndex = routeIndex; 
      currentStepIndex = 0;
      announcedSteps.clear();
      updateStepUI(routeIndex, 0, 'active');
      const firstStep = steps[0];
      const distText = firstStep.distance < 1000 
        ? `${firstStep.distance.toFixed(0)} meters` 
        : `${(firstStep.distance / 1000).toFixed(1)} kilometers`;
      speak(`${firstStep.text}. Proceed for ${distText}.`, "step", { interrupt: true });
      announcedSteps.add(0);
    }
  });
}

map.on('click', e => {
  const latlng = e.latlng;
  let startPoint = null;
  if (routes.length > 0) {
    const lastRoute = routes[routes.length - 1];
    const lastSteps = lastRoute.steps;
    if (lastSteps.length > 0) { 
      const lastStep = lastSteps[lastSteps.length - 1]; 
      startPoint = L.latLng(lastStep.lat, lastStep.lng); 
    }
  }
  if (!startPoint) startPoint = userMarker ? userMarker.getLatLng() : map.getCenter();
  openPreviewTo(latlng, "Pinned location", true);
  preview.start = startPoint;
});

function rebuildRoutes() {
  const driver = userMarker ? userMarker.getLatLng() : map.getCenter();
  const validWaypoints = [driver]; const validMarkers = [];
  waypointMarkers.forEach((m) => { if (map.hasLayer(m)) { validWaypoints.push(m.getLatLng()); validMarkers.push(m); } });
  waypoints.length = 0; waypointMarkers.length = 0;
  waypoints.push(...validWaypoints); waypointMarkers.push(...validMarkers);
  routes.forEach(r => { try { map.removeControl(r.rc); } catch {} try { map.removeLayer(r.group); } catch {} });
  routes = []; document.getElementById("routePanel").innerHTML = "";
  if (waypoints.length < 2) return;
  for (let i = 1; i < waypoints.length; i++) {
    createRoute(waypoints[i-1], waypoints[i], colors[(i-1)%colors.length], waypointMarkers[i-1], i-1);
  }
}

let mapFull = false;
document.getElementById("map-toggle").addEventListener("click",()=>{
  const mapContainer=document.querySelector(".map-container");
  const button=document.getElementById("map-toggle");
  if(!mapFull){
    mapContainer.style.position="fixed"; mapContainer.style.top="0"; mapContainer.style.left="0";
    mapContainer.style.width="100vw"; mapContainer.style.height="100vh"; mapContainer.style.zIndex="2000";
    button.innerText="Restore Map"; mapFull=true; setTimeout(()=>map.invalidateSize(),300);
  }else{
    mapContainer.style.position=""; mapContainer.style.width=""; mapContainer.style.height=""; mapContainer.style.zIndex="";
    button.innerText="Full Map"; mapFull=false; setTimeout(()=>map.invalidateSize(),300);
  }
});
map.on('dragstart zoomstart', () => { autoFollow = false; });

const locateBtn = document.getElementById("locate-btn");
locateBtn.addEventListener("click", () => {
  if (!userMarker) { alert("User location not available yet!"); return; }
  autoFollow = !autoFollow;
  const userPos = userMarker.getLatLng(); map.setView(userPos, 19, { animate: true });
  locateBtn.style.transform = "scale(0.9)"; setTimeout(() => locateBtn.style.transform = "scale(1)", 150);
  if (autoFollow) { locateBtn.style.background = "#00b300"; locateBtn.title = "Following car (tap to stop)"; }
  else { locateBtn.style.background = "#1e90ff"; locateBtn.title = "Recenter to my location"; }
});

// ===== Search =====
const input = document.getElementById("searchInput");
const suggestBox = document.getElementById("suggestBox");
let results = []; let searchTimer = null;

async function getSearchResults(query) {
  const center = userMarker ? userMarker.getLatLng() : map.getCenter();
  const lang = driverCountry ? driverCountry.toLowerCase() : "en";
  const latlngMatch = query.match(/^([-]?[0-9]+\.[0-9]+)[,\s]+([-]?[0-9]+\.[0-9]+)$/);
  if (latlngMatch) return [{ name:"Pinned Location", display_name:"Manual coordinate input", lat:parseFloat(latlngMatch[1]), lon:parseFloat(latlngMatch[2]), score:100 }];
  let allResults = [];
  try {
    const ph = await fetch(`https://photon.komoot.io/api/?q=${encodeURIComponent(query)}&lat=${center.lat}&lon=${center.lng}&limit=8&lang=${lang}`);
    const json = await ph.json();
    if (json.features) json.features.forEach(f => allResults.push({ name:f.properties.name || f.properties.street || f.properties.locality || "Unnamed",
      display_name:[f.properties.name, f.properties.city, f.properties.country].filter(Boolean).join(", "),
      lat:f.geometry.coordinates[1], lon:f.geometry.coordinates[0], score:50 }));
  } catch {}
  try {
    const nm = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=8&addressdetails=1&accept-language=${lang}`);
    const data = await nm.json();
    data.forEach(f => allResults.push({ name:f.display_name.split(",")[0], display_name:f.display_name, lat:parseFloat(f.lat), lon:parseFloat(f.lon), score:70 }));
  } catch {}
  try {
    const gr = await fetch(`https://geocode.maps.co/search?q=${encodeURIComponent(query)}`);
    const gd = await gr.json();
    gd.forEach(f => allResults.push({ name:f.display_name.split(",")[0], display_name:f.display_name, lat:parseFloat(f.lat), lon:parseFloat(f.lon), score:90 }));
  } catch {}
  allResults.sort((a,b)=>b.score-a.score);
  return allResults.slice(0,10);
}

input.oninput = () => {
  const q = input.value.trim(); if (searchTimer) clearTimeout(searchTimer);
  if (!q) return (suggestBox.style.display = "none");
  searchTimer = setTimeout(async () => {
    const data = await getSearchResults(q); results = data; suggestBox.innerHTML = "";
    if (!data.length) { suggestBox.style.display = "none"; return; }
    data.forEach((f,i)=>{
      const div = document.createElement("div");
      div.className="suggest-item";
      div.innerHTML=`<b>${f.name}</b><div style="font-size:12px;color:#bbb;">${f.display_name}</div>`;
      div.onclick = () => selectResult(i);
      suggestBox.appendChild(div);
    });
    suggestBox.style.display="block";
  }, 300);
};
document.addEventListener("click", e => { if (!suggestBox.contains(e.target) && e.target !== input) suggestBox.style.display = "none"; });
function selectResult(i){
  const f = results[i]; if (!f) return; const latlng = L.latLng(f.lat, f.lon);
  openPreviewTo(latlng, f.name, true);
  input.value = ""; suggestBox.style.display = "none";
  map.flyTo(latlng, 16, { animate: true, duration: 1.2 });
}

const micBtn = document.getElementById('micBtn');
micBtn.onclick = async () => {
  if (!('webkitSpeechRecognition' in window)) { alert('Speech Recognition not supported on this browser'); return; }
  try {
    await navigator.mediaDevices.getUserMedia({ audio: true });
    const recog = new webkitSpeechRecognition(); recog.lang='en-US'; recog.interimResults=false; recog.maxAlternatives=1;
    micBtn.textContent='üéôÔ∏è Listening...'; recog.start();
    recog.onresult = (e) => { const text=e.results[0][0].transcript; input.value=text; input.dispatchEvent(new Event('input')); };
    recog.onerror = () => { micBtn.textContent='üé§'; };
    recog.onend = () => { micBtn.textContent='üé§'; };
  } catch { alert('Please allow microphone permission to use voice search.'); }
};
</script>
</body>
</html>
